

using openTK_thing;

class Program
{
    static void Main(string[] args)
    {
        /*
        Как в целом все работает?
        OpenTK работает в 2х областях
        В каждый момент времени одна область показывается
        а другая отрисовывается (рендеринг)
        После завешения рендеринга эти области свапаются
        В OpenGL все в 3-х мерном, а экран - двумерный
        Поэтому большая часть работы OpenGL - 
                         - преобразовывать 3-мерные пиксели в 2-мерные
        Этот процесс управляется графическим конвейером OpenGL



        У конвейера 2 части:
        1) преобразование 3-мерных в 2-мерные координаты
        2) преобразование 2-мерных координат в цветные пиксели

        Конвейер принимает на вход набор 3-мерных координат
        и преобразовывает их в 2-мерные цветные пиксели
        У конвейера есть несколько этапов
        Причем каждый этап формирует результат, который
        передается на следующий этап конвейера

        Шейдеры -  небольшие программы на GPU, 
        обрабатывающие данные в графическом конвейере

        Шейдеры можно писать свои






        Этапы конвейера:      
        +1) Вершинный шейдер              
        Вершини перемещаются в позиции.
        Запускается столько раз, сколько вершин в программе.


        -2) Сборка формы             
        Триангуляция (вершины в треугольники объединяются)
        
        +3) Шейдер геометрии              
        Необязательный, точно настраивает результаты Shape Assembly)

        -4) Растеризация             
        Треугольники преобразуются в фрагменты

        +5) Фрагментный шейдер            
        Необязательный, фрагменты модифицируются для включения цветовых данных
                                             (текстура + освещение применяются)
        Запускается для каждого пикселя

        -6) Тесты и смешивание  
        Результат фрагментного шейдера интегрируется с остальной сценой

        ---->>>( +   значит можно написать свой                         )<<<----
        ---->>>( -   значит свой не напишешь,но можно немного настроить )<<<----





        GL.Clear() очищает экран цветом, установленным GL.ClearColor(R,G,B,A)
        Red,Green,Blue,Alpha(непрозрачность) - принимают от 0f до 1f (float) 
        После вызова SwapBuffers()  область показываемая и рендеринга меняются



        Пусть мы знаем данные вершин
        Как их отправить на первый этап конвейера?
        Надо создать память на GPU
        Там мы:
        1) храним данные вершин 
        2) настраиваем, как OpenGL должен интерпретировать память
        3) указываем, как отправлять данные на графическую карту
        Этой памятью мы управляем через буфер вершин (VBO).



        Нам придется указывать,как OpenGL должен
        интерпретировать данные вершин перед рендерингом.
        Эта информация хранится  объекте массива вершин (VAO).
        Он содержит информацию о формате вершин 
        и о том, из каких буфер читать данные.
        */






        // с помощью in объявляем все входные 
        // атрибуты вершин в вершинном шейдере
        // layout (location = 0) задает местоположение входной переменной
        // эта функция - входная точка для шейдера,
        // можно здесь писать любую обработку

        // этот шейдер вычисляет выходной цвет пикселя (RGBA)
        // Red, Green, Blue, Alpha (alpha - непрозрачность)







        using (Game game = new Game(800,400))
        {

            game.Run();
        }
    }

}